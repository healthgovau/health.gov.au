<?php

/**
 * Check if this node is a glossary type or not.
 *
 * @param object $node
 *   The current node.
 * @param array $vars
 *   Storage for data passed back to _health_book_tree_traverse.
 *
 * @see _health_book_tree_traverse
 */
function _health_book_find_glossary($node, array &$vars) {
  // All paragraph ids.
  $pids = [];
  // Glossary term paragraph ids.
  $ptids = [];
  if (isset($node->field_components[LANGUAGE_NONE])) {
    foreach ($node->field_components[LANGUAGE_NONE] as $paragraph) {
      $pids[] = $paragraph['value'];
    }
    $paragraphs = entity_load('paragraphs_item', $pids);
    foreach ($paragraphs as $paragraph) {
      if ($paragraph->bundle == 'glossary') {
        if (property_exists($paragraph, 'field_glossary_apply_tooltips') && $paragraph->field_glossary_apply_tooltips) {
          $type = $paragraph->field_glossary_type[LANGUAGE_NONE][0]['value'];
          foreach ($paragraph->field_glossary_terms[LANGUAGE_NONE] as $para_terms) {
            if (isset($ptids[$type][$node->nid])) {
              $ptids[$type][$node->nid][] = $para_terms['value'];
            }
            else {
              $ptids[$type][$node->nid] = [$para_terms['value']];
            }
          }
        }
      }
    }
  }

  foreach ($ptids as $type => $items) {
    foreach ($items as $nid => $ids) {
      $terms = entity_load('paragraphs_item', $ids);
      foreach ($terms as $term_para) {
        $term = $term_para->field_glossary_term[LANGUAGE_NONE][0]['value'];
        $definition = $term_para->field_glossary_definition[LANGUAGE_NONE][0]['value'];
        $vars[] = [
          'type' => $type,
          'term' => $term,
          'definition' => $definition,
          'url' => url('node/' . $nid) . '#' . _health_prepare_filename($term),
          'id' => _health_prepare_filename($term),
        ];
      }
    }
  }
}

/**
 * Finds all recommendations and renders a cascading tree view.
 *
 * @param int $bid
 *   Book id.
 *
 * @return string
 *   Rendered output.
 */
function _health_book_find_recommendations($bid) {
  $tree = menu_tree_all_data(book_menu_name($bid));
  $tree = array_pop($tree);
  $populated = _health_book_find_recommendations_recursive($tree['below']);
  _health_book_find_recommendations_clean_recursive($populated);
  return _health_book_find_recommendations_render_recursive($populated);
}

/**
 * Recursive for _health_book_table_of_contents().
 *
 * @param array $tree
 *   Menu tree generated by menu_tree_all_data().
 *
 * @return array
 *   Tree.
 */
function _health_book_find_recommendations_recursive(array $tree) {
  foreach ($tree as $key => &$item) {
    if ($node = _health_load_node_from_node_path($item['link']['link_path'])) {

      // Update the title with page number.
      if ($node->field_page_number) {
        $item['link']['title'] = $node->field_page_number[LANGUAGE_NONE][0]['value'] . ' ' . $item['link']['title'];
      }

      // Get the recommendations.
      $pids = [];
      if (isset($node->field_components[LANGUAGE_NONE])) {
        foreach ($node->field_components[LANGUAGE_NONE] as $ref) {
          $pids[] = $ref['value'];
        }
        $paras = entity_load('paragraphs_item', $pids);
        foreach ($paras as $para) {
          if ($para->bundle == 'recommendation') {
            if (!array_key_exists('recommendations', $item)) {
              $item['recommendations'] = [];
            }
            $item['recommendations'][] = entity_view('paragraphs_item', [$para], 'listing_vertical', NULL, TRUE);
          }
        }
      }

    }
    if (!empty($item['below'])) {
      $item['below'] = _health_book_find_recommendations_recursive($item['below']);
    }
  }

  return $tree;
}

/**
 * Remove any tree branches that don't actually have any recommendations.
 *
 * @param array $tree
 *   Menu tree generated by menu_tree_all_data().
 *
 * @return bool
 *   True if the current item has recommendations under it.
 */
function _health_book_find_recommendations_clean_recursive(array &$tree) {
  $found = FALSE;
  foreach ($tree as $key => $item) {
    if (array_key_exists('recommendations', $item)) {
      $found = TRUE;
    }
    elseif (!empty($tree[$key]['below'])) {
      $found = _health_book_find_recommendations_clean_recursive($tree[$key]['below']);
    }
    else {
      unset($tree[$key]);
    }
    if (!$found) {
      unset($tree[$key]);
    }
  }
  return $found;
}

/**
 * Render tree of recommendations.
 *
 * @param array $tree
 *   Menu tree generated by menu_tree_all_data().
 * @param int $level
 *   The heading level to start when rendering titles.
 *
 * @return string
 *   Rendered output.
 */
function _health_book_find_recommendations_render_recursive(array $tree, $level = 1) {
  $output = '';
  foreach ($tree as $key => $item) {
    $output .= '<h' . ($level + 2) . '>' . $item['link']['title'] . '</h' . ($level + 2) . '>';
    if (array_key_exists('recommendations', $item)) {
      foreach ($item['recommendations'] as $recommendation) {
        $output .= render($recommendation);
      }
    }
    if (!empty($item['below'])) {
      $output .= _health_book_find_recommendations_render_recursive($item['below'], $level + 1);
    }
  }
  return $output;
}

/**
 * Finds all table paragraphs in a node and groups them under a node id.
 *
 * @param object $node
 *   The current node.
 * @param array $vars
 *   Storage for data passed back to _health_book_tree_traverse.
 *
 * @see _health_book_tree_traverse
 */
function _health_book_find_tables($node, array &$vars) {
  $pids = [];
  if (isset($node->field_components[LANGUAGE_NONE])) {
    foreach ($node->field_components[LANGUAGE_NONE] as $ref) {
      $pids[] = $ref['value'];
    }
    $paras = entity_load('paragraphs_item', $pids);
    foreach ($paras as $para) {
      if ($para->bundle == 'content_table') {
        $para->parent_node = $node;
        if (isset($vars[$node->nid])) {
          $vars[$node->nid]['tables'][] = $para;
        }
        else {
          $vars[$node->nid] = ['node' => $node, 'tables' => [$para]];
        }
      }
    }
  }
}

/**
 * Get the table of contents for a book for use with theme_list_item().
 *
 * @param int $bid
 *   Book id.
 *
 * @return array
 *   Array for use with theme_list_item().
 */
function _health_book_table_of_contents($bid) {
  $tree = menu_tree_all_data(book_menu_name($bid));
  $tree = array_pop($tree);
  return _health_book_table_of_contents_recursive($tree['below']);
}

/**
 * Recursive for _health_book_table_of_contents().
 *
 * @param array $tree
 *   Menu tree generated by menu_tree_all_data().
 *
 * @return array
 *   A nested list ready for render by theme_list.
 */
function _health_book_table_of_contents_recursive(array $tree) {
  $toc = [];
  foreach ($tree as $key => $item) {
    $list_item = [];
    $title = $item['link']['title'];
    if ($node = _health_load_node_from_node_path($item['link']['link_path'])) {
      $title = $node->title;
      if ($node->field_page_number) {
        $title = $node->field_page_number[LANGUAGE_NONE][0]['value'] . ' ' . $title;
      }
    }
    $list_item['data'] = l($title, $item['link']['link_path']);
    if (!empty($item['below'])) {
      $list_item['children'] = _health_book_table_of_contents_recursive($item['below']);
    }
    $toc[] = $list_item;
  }
  return $toc;
}


/**
 * Traverse a book and run a callback on each node.
 *
 * @param int $bid
 *   Book id.
 * @param string $callback
 *   Callback function.
 *
 * @return array
 *   Array of variables that have been modified by the callback.
 */
function _health_book_tree_traverse($bid, $callback) {
  $tree = menu_tree_all_data(book_menu_name($bid));
  $vars = [];
  _health_book_tree_traverse_recursive($tree, $callback, $vars);
  return $vars;
}

/**
 * Recursive function to traverse a book tree and run a callback on each node.
 *
 * @param array $tree
 *   Menu tree generated by menu_tree_all_data().
 * @param string $callback
 *   Callback function, accepts 2 arguments:
 *    node - The current node
 *    vars - Array of variables for use by the callback to store variables
 *   whilst traversing.
 * @param array $vars
 *   Array of variables that have been modified by the callback.
 */
function _health_book_tree_traverse_recursive(array &$tree, $callback, array &$vars) {
  foreach ($tree as $key => $item) {
    $nid = str_replace('node/', '', $item['link']['link_path']);
    $node = node_load($nid);
    $callback($node, $vars);
    if (!empty($item['below'])) {
      _health_book_tree_traverse_recursive($item['below'], $callback, $vars);
    }
  }
}

/**
 * Replace footnote tokens eg [[1]] with markup and link.
 *
 * @param string $markup
 *   HTML markup.
 *
 * @return string
 *   Modified markup
 */
function _health_book_footnote_links($markup) {
  if (preg_match_all("/(\[\[)(\d+)(\]\])/", $markup, $matches) > 0) {
    foreach ($matches[2] as $delta => $match) {
      $split = explode(',', $match);
      $items = [];
      foreach ($split as $ref) {
        $clean = _health_prepare_filename($ref);
        $items[$clean] = $ref;
      }
      $replacement = theme('health_footnote-link', ['items' => $items]);
      $markup = str_replace($matches[0][$delta], $replacement, $markup);
    }
  }
  return $markup;
}

/**
 * Replace reference tokens {{WHO 2017}} with markup and link.
 *
 * @param string $markup
 *   HTML markup.
 *
 * @return string
 *   Modified markup
 */
function _health_book_reference_links($markup) {
  if (preg_match_all("/(\{\{)([^\{\}]+)(\}\})/", $markup, $matches) > 0) {
    foreach ($matches[2] as $delta => $match) {
      $split = explode(',', $match);
      $items = [];
      foreach ($split as $ref) {
        $clean = _health_prepare_filename($ref);
        $items[$clean] = $ref;
      }
      $replacement = theme('health_reference-link', ['items' => $items]);
      $markup = str_replace($matches[0][$delta], $replacement, $markup);
    }
  }
  return $markup;
}
