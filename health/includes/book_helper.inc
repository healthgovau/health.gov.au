<?php
/**
 * Add heading numbers to a menu.
 *
 * @param $tree
 *   Array of links generated by menu_tree_all_data().
 * @param string $num
 *   The current heading number, eg 1.2 or 3.4.5
 * @param $active_num
 *   A variable to hold the result of the current nodes heading number when
 *   found.
 */
function _health_book_heading_children(&$tree, $num = '0', &$active_num) {
  if ($num != '0') {
    $num .= '.0';
  }
  foreach ($tree as $key => &$item) {
    $nid = str_replace('node/', '', $item['link']['link_path']);
    $node = node_load($nid, NULL, TRUE);
    if (isset($node->field_exclude_from_numbering[LANGUAGE_NONE]) && $node->field_exclude_from_numbering[LANGUAGE_NONE][0]['value'] == 1) {
      $item['link']['localized_options']['attributes']['class'] = ['no-number'];
    }
    else {
      $num = _health_book_next_number($num);

      // Save the node with the new title if it has changed.
      $original_title = $node->title;
      $new_title = $num . ' ' . preg_replace("/^[\d\. ]+(.)/", "$1", $item['link']['title']);
      if ($original_title !== $new_title) {
        $node->title = $new_title;
        $node->revision = TRUE;
        node_save($node);
      }

      if ($current_node = menu_get_object()) {
        if ($item['link']['link_path'] == ('node/' . $current_node->nid)) {
          $active_num = $num;
        }
      }
    }

    if (isset($item['below'])) {
      _health_book_heading_children($item['below'], $num, $active_num);
    }
  }
}

/**
 * Callback for use with _health_book_tree_traverse();
 *
 * Check if this node is a glossary type or not.
 *
 * @param $node
 * @param $vars
 */
function _health_book_find_glossary($node, &$vars) {
  $pids = []; // All paragraph ids
  $ptids = []; // Glossary term paragraph ids
  if (isset($node->field_components[LANGUAGE_NONE])) {
    foreach ($node->field_components[LANGUAGE_NONE] as $paragraph) {
      $pids[] = $paragraph['value'];
    }
    $paragraphs = entity_load('paragraphs_item', $pids);
    foreach ($paragraphs as $paragraph) {
      if ($paragraph->bundle == 'glossary') {
        foreach ($paragraph->field_glossary_terms[LANGUAGE_NONE] as $para_terms) {
          if (isset($ptids[$node->nid])) {
            $ptids[$node->nid][] = $para_terms['value'];
          } else {
            $ptids[$node->nid] = [$para_terms['value']];
          }
        }
      }
    }
  }

  foreach($ptids as $nid => $ids) {
    $terms = entity_load('paragraphs_item', $ids);
    foreach ($terms as $term_para) {
      $term = $term_para->field_glossary_term[LANGUAGE_NONE][0]['value'];
      $definition = $term_para->field_glossary_definition[LANGUAGE_NONE][0]['value'];
      $vars[] = ['term' => $term, 'definition' => $definition, 'nid' => $nid];
    }
  }
}

/**
 * Callback for use with _health_book_tree_traverse();
 *
 * Finds all recommendation paragraphs in a node and groups it under a node id.
 *
 * @param $node
 * @param $vars
 */
function _health_book_find_recommendations($node, &$vars) {
  $pids = [];
  if (isset($node->field_components[LANGUAGE_NONE])) {
    foreach ($node->field_components[LANGUAGE_NONE] as $ref) {
      $pids[] = $ref['value'];
    }
    $paras = entity_load('paragraphs_item', $pids);
    foreach ($paras as $para) {
      if ($para->bundle == 'recommendation') {
        $para->parent_node = $node;
        if (isset($vars[$node->nid])) {
          $vars[$node->nid]['recommendations'][] = $para;
        }
        else {
          $vars[$node->nid] = ['node' => $node, 'recommendations' => [$para]];
        }
      }
    }
  }
}

/**
 * Callback for use with _health_book_tree_traverse();
 *
 * Finds all recommendation paragraphs in a node and groups it under a node id.
 *
 * @param $node
 * @param $vars
 */
function _health_book_find_tables($node, &$vars) {
  $pids = [];
  if (isset($node->field_components[LANGUAGE_NONE])) {
    foreach ($node->field_components[LANGUAGE_NONE] as $ref) {
      $pids[] = $ref['value'];
    }
    $paras = entity_load('paragraphs_item', $pids);
    foreach ($paras as $para) {
      if ($para->bundle == 'content_table') {
        $para->parent_node = $node;
        if (isset($vars[$node->nid])) {
          $vars[$node->nid]['tables'][] = $para;
        }
        else {
          $vars[$node->nid] = ['node' => $node, 'tables' => [$para]];
        }
      }
    }
  }
}

/**
 * Get the table of contents for a book for use with theme_list_item().
 *
 * @param $bid
 *   Book id.
 *
 * @return array
 *   Array for use with theme_list_item().
 */
function _health_book_table_of_contents($bid) {
  $tree = menu_tree_all_data(book_menu_name($bid));
  $tree = array_pop($tree);
  return _health_book_table_of_contents_recursive($tree['below']);
}

/**
 * Recursive for _health_book_table_of_contents().
 *
 * @param $tree
 *   Menu tree generated by menu_tree_all_data().
 *
 * @return array
 */
function _health_book_table_of_contents_recursive($tree) {
  $toc = [];
  foreach ($tree as $key => $item) {
    $list_item = [];
    $list_item['data'] = l($item['link']['title'], $item['link']['link_path']);
    if (isset($item['below'])) {
      $list_item['children'] = _health_book_table_of_contents_recursive($item['below']);
    }
    $toc[] = $list_item;
  }
  return $toc;
}


/**
 * Traverse a book and run a callback on each node.
 *
 * @param $bid
 *   Book id
 * @param $callback
 *   Callback function
 *
 * @return array
 *   Array of variables that have been modified by the callback.
 */
function _health_book_tree_traverse($bid, $callback) {
  $tree = menu_tree_all_data(book_menu_name($bid));
  $vars = [];
  _health_book_tree_traverse_recursive($tree, $callback, $vars);
  return $vars;
}

/**
 * Recursive function to traverse a book tree and run a callback on each node.
 *
 * @param $tree
 *   Tree created by menu_tree_all_data().
 * @param $callback
 *   Callback function, accepts 2 arguments:
 *    node - The current node
 *    vars - Array of variables for use by the callback to store variables
 *   whilst traversing.
 * @param $vars
 */
function _health_book_tree_traverse_recursive(&$tree, $callback, &$vars) {
  foreach ($tree as $key => $item) {
    $nid = str_replace('node/', '', $item['link']['link_path']);
    $node = node_load($nid);
    $callback($node, $vars);
    if (isset($item['below'])) {
      _health_book_tree_traverse_recursive($item['below'], $callback, $vars);
    }
  }
}


/**
 * Replace footnote tokens [[1]] with markup and link.
 *
 * @param $markup
 *
 * @return mixed
 */
function _health_book_footnote_links($markup) {
  if (preg_match_all("/(\[\[)(.+)(\]\])/", $markup, $matches) > 0) {
    foreach ($matches[2] as $delta => $match) {
      $split = explode(',', $match);
      $items = [];
      foreach ($split as $ref) {
        $clean = _health_prepare_filename($ref);
        $items[$clean] = $ref;
      }
      $replacement = theme('health_footnote-link', ['items' => $items]);
      $markup = str_replace($matches[0][$delta], $replacement, $markup);
    }
  }
  return $markup;
}

/**
 * Format a definition (or abbreviation) for accessibility and replace it within the markup.
 *
 * @param $type
 *   abbreviation or definition
 * @param $term
 * @param $definition
 * @param $markup
 *
 * @return mixed
 */
function _health_book_definition($type, $term, $definition, $markup, $url) {
  $term_regex = str_replace('/', '\/', preg_quote(check_plain($term)));
  if (preg_match_all("/([^A-Z\[\{])(" . $term_regex . ")([^A-Z\]\}])/", $markup, $matches) > 0) {
    foreach ($matches[2] as $delta => $match) {
      $split = explode(',', $match);
      $items = [];
      foreach ($split as $ref) {
        $clean = _health_prepare_filename($ref);
        $items[$clean] = $ref;
      }
      $replacement = theme('health_' . $type, [
        'term' => $term,
        'definition' => $definition,
        'url' => $url
      ]);
      $markup = str_replace($matches[0][$delta], $matches[1][$delta] . $replacement . $matches[3][$delta], $markup);
    }
  }
  return $markup;
}

/**
 * Replace reference tokens {{WHO 2017}} with markup and link.
 *
 * @param $markup
 *
 * @return mixed
 */
function _health_book_reference_links($markup) {
  if (preg_match_all("/(\{\{)([^\{\}]+)+(\}\})/", $markup, $matches) > 0) {
    foreach ($matches[2] as $delta => $match) {
      $split = explode(',', $match);
      $items = [];
      foreach ($split as $ref) {
        $clean = _health_prepare_filename($ref);
        $items[$clean] = $ref;
      }
      $replacement = theme('health_reference-link', ['items' => $items]);
      $markup = str_replace($matches[0][$delta], $replacement, $markup);
    }
  }
  return $markup;
}

/**
 * Get the next number of a heading number.
 * Eg 1.2 -> 1.3 or 2.5.3.13 -> 2.5.3.14
 *
 * @param $num
 * @return string
 */
function _health_book_next_number($num) {
  $parts = explode('.', $num);
  $last = (int)$parts[count($parts)-1];
  $parts[count($parts)-1] = ++$last;
  return implode('.', $parts);
}
