<?php

/**
 * Callback for use with _health_book_tree_traverse();
 *
 * Check if this node is a glossary type or not.
 *
 * @param $node
 * @param $vars
 */
function _health_book_find_glossary($node, &$vars) {
  $pids = []; // All paragraph ids
  $ptids = []; // Glossary term paragraph ids
  if (isset($node->field_components[LANGUAGE_NONE])) {
    foreach ($node->field_components[LANGUAGE_NONE] as $paragraph) {
      $pids[] = $paragraph['value'];
    }
    $paragraphs = entity_load('paragraphs_item', $pids);
    foreach ($paragraphs as $paragraph) {
      if ($paragraph->bundle == 'glossary') {
        if (property_exists($paragraph, 'field_glossary_apply_tooltips') && $paragraph->field_glossary_apply_tooltips) {
          $type = $paragraph->field_glossary_type[LANGUAGE_NONE][0]['value'];
          foreach ($paragraph->field_glossary_terms[LANGUAGE_NONE] as $para_terms) {
            if (isset($ptids[$type][$node->nid])) {
              $ptids[$type][$node->nid][] = $para_terms['value'];
            }
            else {
              $ptids[$type][$node->nid] = [$para_terms['value']];
            }
          }
        }
      }
    }
  }

  foreach($ptids as $type => $items) {
    foreach($items as $nid => $ids) {
      $terms = entity_load('paragraphs_item', $ids);
      foreach ($terms as $term_para) {
        $term = $term_para->field_glossary_term[LANGUAGE_NONE][0]['value'];
        $definition = $term_para->field_glossary_definition[LANGUAGE_NONE][0]['value'];
        $vars[] = [
          'type' => $type,
          'term' => $term,
          'definition' => $definition,
          'url' => url('node/' . $nid) . '#' . _health_prepare_filename($term),
          'id' => _health_prepare_filename($term)
        ];
      }
    }
  }
}

/**
 * Callback for use with _health_book_tree_traverse();
 *
 * Finds all recommendation paragraphs in a node and groups it under a node id.
 *
 * @param $node
 * @param $vars
 */
function _health_book_find_recommendations($node, &$vars) {
  $pids = [];
  if (isset($node->field_components[LANGUAGE_NONE])) {
    foreach ($node->field_components[LANGUAGE_NONE] as $ref) {
      $pids[] = $ref['value'];
    }
    $paras = entity_load('paragraphs_item', $pids);
    foreach ($paras as $para) {
      if ($para->bundle == 'recommendation') {
        $para->parent_node = $node;
        if (isset($vars[$node->nid])) {
          $vars[$node->nid]['recommendations'][] = $para;
        }
        else {
          $vars[$node->nid] = ['node' => $node, 'recommendations' => [$para]];
        }
      }
    }
  }
}

/**
 * Callback for use with _health_book_tree_traverse();
 *
 * Finds all recommendation paragraphs in a node and groups it under a node id.
 *
 * @param $node
 * @param $vars
 */
function _health_book_find_tables($node, &$vars) {
  $pids = [];
  if (isset($node->field_components[LANGUAGE_NONE])) {
    foreach ($node->field_components[LANGUAGE_NONE] as $ref) {
      $pids[] = $ref['value'];
    }
    $paras = entity_load('paragraphs_item', $pids);
    foreach ($paras as $para) {
      if ($para->bundle == 'content_table') {
        $para->parent_node = $node;
        if (isset($vars[$node->nid])) {
          $vars[$node->nid]['tables'][] = $para;
        }
        else {
          $vars[$node->nid] = ['node' => $node, 'tables' => [$para]];
        }
      }
    }
  }
}

/**
 * Get the table of contents for a book for use with theme_list_item().
 *
 * @param $bid
 *   Book id.
 *
 * @return array
 *   Array for use with theme_list_item().
 */
function _health_book_table_of_contents($bid) {
  $tree = menu_tree_all_data(book_menu_name($bid));
  $tree = array_pop($tree);
  return _health_book_table_of_contents_recursive($tree['below']);
}

/**
 * Recursive for _health_book_table_of_contents().
 *
 * @param $tree
 *   Menu tree generated by menu_tree_all_data().
 *
 * @return array
 */
function _health_book_table_of_contents_recursive($tree) {
  $toc = [];
  foreach ($tree as $key => $item) {
    $list_item = [];
    $title = $item['link']['title'];
    if ($node = _health_load_node_from_node_path($item['link']['link_path'])) {
      $title = $node->title;
      if ($node->field_page_number) {
        $title = $node->field_page_number[LANGUAGE_NONE][0]['value'] . ' ' . $title;
      }
    }
    $list_item['data'] = l($title, $item['link']['link_path']);
    if (isset($item['below'])) {
      $list_item['children'] = _health_book_table_of_contents_recursive($item['below']);
    }
    $toc[] = $list_item;
  }
  return $toc;
}


/**
 * Traverse a book and run a callback on each node.
 *
 * @param $bid
 *   Book id
 * @param $callback
 *   Callback function
 *
 * @return array
 *   Array of variables that have been modified by the callback.
 */
function _health_book_tree_traverse($bid, $callback) {
  $tree = menu_tree_all_data(book_menu_name($bid));
  $vars = [];
  _health_book_tree_traverse_recursive($tree, $callback, $vars);
  return $vars;
}

/**
 * Recursive function to traverse a book tree and run a callback on each node.
 *
 * @param $tree
 *   Tree created by menu_tree_all_data().
 * @param $callback
 *   Callback function, accepts 2 arguments:
 *    node - The current node
 *    vars - Array of variables for use by the callback to store variables
 *   whilst traversing.
 * @param $vars
 */
function _health_book_tree_traverse_recursive(&$tree, $callback, &$vars) {
  foreach ($tree as $key => $item) {
    $nid = str_replace('node/', '', $item['link']['link_path']);
    $node = node_load($nid);
    $callback($node, $vars);
    if (isset($item['below'])) {
      _health_book_tree_traverse_recursive($item['below'], $callback, $vars);
    }
  }
}


/**
 * Replace footnote tokens [[1]] with markup and link.
 *
 * @param $markup
 *
 * @return mixed
 */
function _health_book_footnote_links($markup) {
  if (preg_match_all("/(\[\[)(.+)(\]\])/", $markup, $matches) > 0) {
    foreach ($matches[2] as $delta => $match) {
      $split = explode(',', $match);
      $items = [];
      foreach ($split as $ref) {
        $clean = _health_prepare_filename($ref);
        $items[$clean] = $ref;
      }
      $replacement = theme('health_footnote-link', ['items' => $items]);
      $markup = str_replace($matches[0][$delta], $replacement, $markup);
    }
  }
  return $markup;
}

/**
 * Replace reference tokens {{WHO 2017}} with markup and link.
 *
 * @param $markup
 *
 * @return mixed
 */
function _health_book_reference_links($markup) {
  if (preg_match_all("/(\{\{)([^\{\}]+)(\}\})/", $markup, $matches) > 0) {
    foreach ($matches[2] as $delta => $match) {
      $split = explode(',', $match);
      $items = [];
      foreach ($split as $ref) {
        $clean = _health_prepare_filename($ref);
        $items[$clean] = $ref;
      }
      $replacement = theme('health_reference-link', ['items' => $items]);
      $markup = str_replace($matches[0][$delta], $replacement, $markup);
    }
  }
  return $markup;
}